package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"
)

var cmd = flag.String("cmd", "", "")

type apiParam struct {
	Description string `json:"description"`
	Length      int    `json:"length"`
	Required    bool   `json:"required"`
	Name        string `json:"name"`
	Type        string `json:"type"`
}

func (p apiParam) CapitalizedName() string {
	return strings.ToUpper(p.Name[0:1]) + p.Name[1:]
}

func (p apiParam) OmitEmpty() string {
	if !p.Required {
		return ",omitempty"
	}
	return ""
}

type apiCall struct {
	Description string     `json:"description"`
	IsAsync     bool       `json:"isasync"`
	Name        string     `json:"name"`
	Params      []apiParam `json:"params"`
}

func (c apiCall) CapitalizedName() string {
	return strings.ToUpper(c.Name[0:1]) + c.Name[1:]
}

func (c apiCall) AsyncText() string {
	return "Async"
}

var api struct {
	Api []apiCall `json:"api"`
}

var callTpl = `
// Code Generated by "foo"; DO NOT EDIT.

// {{.CapitalizedName}} ({{.AsyncText}}) {{.Description}}
//
// URL: ...{{.Name}}
type {{.CapitalizedName}} struct {
{{- range .Params}}
    // {{ .CapitalizedName }} - {{ .Description }}
    {{.CapitalizedName}} {{.Type}} ` + "`" + `json:"{{.Name}}{{.OmitEmpty}}" doc:"{{.Description}}"` + "`" + `
{{ end }}
}
`

func main() {
	// GOPATH
	// GOFILE
	// GOPACKAGE
	// GOLINE

	flag.Parse()
	if flag.NArg() == 0 {
		fmt.Printf("provide json file!")
		os.Exit(1)
	}

	var source = flag.Arg(0)
	fmt.Printf("%s cmd=%s", source, *cmd)

	sourceFile, _ := os.Open(source)
	parser := json.NewDecoder(sourceFile)
	if err := parser.Decode(&api); err != nil {
		fmt.Printf(err.Error())
		os.Exit(2)
	}

	for _, a := range api.Api {
		if a.Name == *cmd {
			t := template.Must(template.New("call").Parse(callTpl))
			if err := t.Execute(os.Stdout, a); err != nil {
				fmt.Printf(err.Error())
				os.Exit(2)
			}
			os.Exit(0)
		}
	}
}
